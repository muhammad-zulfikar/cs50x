sort1 uses: selection sort.

How do you know?:

- time ./sort1 random50000.txt
  real    0m6.743s
- time ./sort1 reversed50000.txt
  real    0m5.536s
- time ./sort1 sorted50000.txt
  real    0m1.186s

it takes a longer time for a list of random numbers, might be using a slower quadratic-time sorting method O(n^2).
and that noticable faster time for already sorted list, which is a key property of using selection sort algorithm.


sort2 uses: merge sort.

How do you know?:
- time ./sort2 random50000.txt
  real    0m0.923s
- time ./sort2 reversed50000.txt
  real    0m0.778s
- time ./sort2 sorted50000.txt
  real    0m0.893s

based on the significantly smaller runtimes than other sort method in all of the datasets,
sort2 is likely using more efficient algorithm, most likely merge sort O(n log n).


sort3 uses: bubble sort.

How do you know?:
- time ./sort3 random50000.txt
  real    0m2.792s
- time ./sort3 reversed50000.txt
  real    0m3.160s
- time ./sort3 sorted50000.txt
  real    0m3.058s

the runtimes are all similar regardless of input order. sort3 demonstrating O(n^2) in all cases.
sort3 is likely using a quadratic-time sorting algorithm, possibly bubble sort.
