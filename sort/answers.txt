sort1 uses: selection sort.

How do you know?:

- time ./sort1 random50000.txt
  real    0m6.743s
- time ./sort1 reversed50000.txt
  real    0m5.536s
- time ./sort1 sorted50000.txt
  real    0m1.186s

it takes a longer time for a list of random numbers, might be using a slower quadratic-time sorting method.
and that noticable faster time for already sorted list, which is a key property of using selection sort algorithm.


sort2 uses: merge sort.

How do you know?:
- time ./sort2 random50000.txt
  real    0m0.923s
- time ./sort2 reversed50000.txt
  real    0m0.778s
- time ./sort2 sorted50000.txt
  real    0m0.893s

based on the significantly smaller times than other sort method in all of the datasets,
sort2 is likely using more efficient algorithm, which possibly merge sort O(n log n).


sort3 uses: bubble sort.

How do you know?:
- time ./sort3 random50000.txt
    real    0m2.792s
- time ./sort3 reversed50000.txt
    real    0m3.160s
- time ./sort3 sorted50000.txt
    real    0m3.058s
Based on the larger times for both random and reversed datasets, and the similar times for sorted datasets,
sort3 is likely using a quadratic-time sorting algorithm, possibly bubble sort.
